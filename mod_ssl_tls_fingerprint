Description: Adds fingerprinting variables
 <long description that can span multiple lines, optional>
Author: <name and email of author, optional>
Origin: <upstream|backport|vendor|other>, <URL, required except if Author is present>
Bug: <URL to the upstream bug report if any, implies patch has been forwarded, optional>
Bug-<Vendor>: <URL to the vendor bug report if any, optional>
Forwarded: <URL|no|not-needed, useless if you have a Bug field, optional>
Applied-Upstream: <version|URL|commit, identifies patches merged upstream, optional>
Reviewed-by: <name and email of a reviewer, optional>
Last-Update: 2024-09-03 <YYYY-MM-DD, last update of the meta-information, optional>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -1515,6 +1515,15 @@
     "SSL_SRP_USER",
     "SSL_SRP_USERINFO",
 #endif
+    "SSL_CLIENTHELLO_VERSION",
+    "SSL_CLIENTHELLO_CIPHERS",
+    "SSL_CLIENTHELLO_EXTENSION_IDS",
+    "SSL_CLIENTHELLO_EC_GROUPS",
+    "SSL_CLIENTHELLO_EC_FORMATS",
+    "SSL_CLIENTHELLO_SIG_ALGOS",
+    "SSL_CLIENTHELLO_ALPN",
+    "SSL_CLIENTHELLO_COMP_METHODS",
+    "SSL_CLIENTHELLO_SUPPORTED_VERSIONS",
     NULL
 };
 
@@ -2440,6 +2449,49 @@
 }
 
 #if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(LIBRESSL_VERSION_NUMBER)
+
+/*
+ * Copy data from clienthello for env vars use later
+ */
+static void copy_clienthello_vars(conn_rec *c, SSL *ssl)
+{
+    SSLConnRec *sslcon;
+    modssl_clienthello_vars *clienthello_vars;
+    const unsigned char *data;
+    int *ids;
+
+
+    sslcon = myConnConfig(c);
+    sslcon->clienthello_vars = NULL;
+
+    //check to see if we should collect clienthello or not
+    sslcon->clienthello_vars = apr_palloc(c->pool, sizeof(*clienthello_vars));
+    clienthello_vars = sslcon->clienthello_vars;
+
+    if (clienthello_vars) {
+        clienthello_vars->version = SSL_client_hello_get0_legacy_version(ssl);
+        clienthello_vars->ciphers_len = SSL_client_hello_get0_ciphers(ssl, &data);
+        clienthello_vars->ciphers_data = apr_pmemdup(c->pool, data, clienthello_vars->ciphers_len);
+        clienthello_vars->compmethods_len = SSL_client_hello_get0_compression_methods(ssl, &data);
+        clienthello_vars->compmethods_data = apr_pmemdup(c->pool, data, clienthello_vars->compmethods_len);
+        if (SSL_client_hello_get1_extensions_present(ssl, &ids, &clienthello_vars->extids_len) == 1) {
+            clienthello_vars->extids_data = apr_pmemdup(c->pool, ids, clienthello_vars->extids_len * sizeof(int));
+            OPENSSL_free(ids);
+        }
+        SSL_client_hello_get0_ext(ssl, 0x0a, &data, &clienthello_vars->ecgroups_len);
+        clienthello_vars->ecgroups_data = apr_pmemdup(c->pool, data, clienthello_vars->ecgroups_len);
+        SSL_client_hello_get0_ext(ssl, 0x0b, &data, &clienthello_vars->ecformats_len);
+        clienthello_vars->ecformats_data = apr_pmemdup(c->pool, data, clienthello_vars->ecformats_len);
+        SSL_client_hello_get0_ext(ssl, 0x0d, &data, &clienthello_vars->sigalgos_len);
+        clienthello_vars->sigalgos_data = apr_pmemdup(c->pool, data, clienthello_vars->sigalgos_len);
+        SSL_client_hello_get0_ext(ssl, 0x10, &data, &clienthello_vars->alpn_len);
+        clienthello_vars->alpn_data = apr_pmemdup(c->pool, data, clienthello_vars->alpn_len);
+        SSL_client_hello_get0_ext(ssl, 0x2b, &data, &clienthello_vars->versions_len);
+        clienthello_vars->versions_data = apr_pmemdup(c->pool, data, clienthello_vars->versions_len);
+
+    }
+}
+
 /*
  * This callback function is called when the ClientHello is received.
  */
@@ -2495,6 +2547,9 @@
 
 give_up:
     init_vhost(c, ssl, servername);
+    
+    copy_clienthello_vars(c, ssl);
+
     return SSL_CLIENT_HELLO_SUCCESS;
 }
 #endif /* OPENSSL_VERSION_NUMBER < 0x10101000L */
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -53,6 +53,7 @@
 static char *ssl_var_lookup_ssl_cipher(apr_pool_t *p, SSLConnRec *sslconn, char *var);
 static void  ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize);
 static char *ssl_var_lookup_ssl_version(apr_pool_t *p, char *var);
+static char *ssl_var_lookup_ssl_clienthello(apr_pool_t *p, SSLConnRec *sslconn, char *var);
 static char *ssl_var_lookup_ssl_compress_meth(SSL *ssl);
 
 static SSLConnRec *ssl_get_effective_config(conn_rec *c)
@@ -387,6 +388,9 @@
     else if (ssl != NULL && strlen(var) >= 6 && strcEQn(var, "CIPHER", 6)) {
         result = ssl_var_lookup_ssl_cipher(p, sslconn, var+6);
     }
+    else if (ssl != NULL && strlen(var) >= 12 && strcEQn(var, "CLIENTHELLO_", 12)) {
+        result = ssl_var_lookup_ssl_clienthello(p, sslconn, var+12);
+    }
     else if (ssl != NULL && strlen(var) > 18 && strcEQn(var, "CLIENT_CERT_CHAIN_", 18)) {
         sk = SSL_get_peer_cert_chain(ssl);
         result = ssl_var_lookup_ssl_cert_chain(p, sk, var+18);
@@ -867,6 +871,82 @@
     return result;
 }
 
+static char *ssl_var_lookup_ssl_clienthello(apr_pool_t *p, SSLConnRec *sslconn, char *var)
+{
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+    char *value;
+    SSL *ssl;
+    modssl_clienthello_vars *clienthello_vars;
+    int i;
+    int j;
+
+    ssl = sslconn->ssl;
+    clienthello_vars = sslconn->clienthello_vars;
+
+    if (!clienthello_vars)
+        return NULL; 
+
+    if (ssl && strEQ(var, "VERSION")) {
+        //return apr_itoa(p, (int)clienthello_vars->version);
+        return apr_psprintf(p, "%04x", (uint16_t) clienthello_vars->version);
+    } else if (ssl && strEQ(var, "CIPHERS") && (clienthello_vars->ciphers_len > 0)) {
+        value = apr_palloc(p, clienthello_vars->ciphers_len * 2 + 1);
+        ap_bin2hex(clienthello_vars->ciphers_data, clienthello_vars->ciphers_len, value);
+        return value;
+    } else if (ssl && strEQ(var, "EXTENSION_IDS") && (clienthello_vars->extids_len > 0)) {
+        value = apr_palloc(p, clienthello_vars->extids_len * 4 + 1);
+        for (i = 0; i < clienthello_vars->extids_len; i++)
+        {
+            snprintf(value + i * 4, 5, "%04x", (uint16_t) clienthello_vars->extids_data[i]);
+        }
+        return value;
+    } else if (ssl && strEQ(var, "EC_GROUPS") && (clienthello_vars->ecgroups_len > 2)) {
+        value = apr_palloc(p, clienthello_vars->ecgroups_len * 2 + 1 - 2);
+        ap_bin2hex(clienthello_vars->ecgroups_data + 2, clienthello_vars->ecgroups_len - 2, value);
+        return value;
+    } else if (ssl && strEQ(var, "EC_FORMATS") && (clienthello_vars->ecformats_len > 1)) {
+        value = apr_palloc(p, clienthello_vars->ecformats_len * 2 + 1 - 1);
+        ap_bin2hex(clienthello_vars->ecformats_data + 1, clienthello_vars->ecformats_len - 1, value);
+        return value;
+    } else if (ssl && strEQ(var, "SIG_ALGOS") && (clienthello_vars->sigalgos_len > 2)) {
+        value = apr_palloc(p, clienthello_vars->sigalgos_len * 2 + 1 - 2);
+        ap_bin2hex(clienthello_vars->sigalgos_data + 2, clienthello_vars->sigalgos_len - 2, value);
+        return value;
+    } else if (ssl && strEQ(var, "ALPN") && (clienthello_vars->alpn_len > 2)) {
+        value = apr_palloc(p, clienthello_vars->alpn_len * 2 + 1 - 2);
+        ap_bin2hex(clienthello_vars->alpn_data + 2, clienthello_vars->alpn_len - 2, value);
+        //grease means not always gauranteed to be ascii
+        //value = apr_palloc(p, clienthello_vars->alpn_len + 1 - 3);
+        //j = clienthello_vars->alpn_data[2];
+        //for (i = 0; i < clienthello_vars->alpn_len - 3; i++)
+        //{
+        //    if (i == j) {
+        //        //replace len with comma
+        //        j += (unsigned char)clienthello_vars->alpn_data[i + 3];
+        //        j++;
+        //        value[i] = 0x2c;
+        //    } else {
+        //        value[i] = clienthello_vars->alpn_data[i + 3];
+        //    }
+        //}
+        //value[i] = '\0';
+        return value;
+    } else if (ssl && strEQ(var, "COMP_METHODS") && (clienthello_vars->compmethods_len > 0)) {
+        value = apr_palloc(p, clienthello_vars->compmethods_len * 2 + 1);
+        ap_bin2hex(clienthello_vars->compmethods_data, clienthello_vars->compmethods_len, value);
+        return value;
+    } else if (ssl && strEQ(var, "SUPPORTED_VERSIONS") && (clienthello_vars->versions_len > 0)) {
+        value = apr_palloc(p, clienthello_vars->versions_len * 2 + 1 - 1);
+        ap_bin2hex(clienthello_vars->versions_data + 1, clienthello_vars->versions_len - 1, value);
+        return value;
+    }
+#endif
+    return NULL;
+}
+
+
+
+
 static void ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize)
 {
     MODSSL_SSL_CIPHER_CONST SSL_CIPHER *cipher;
--- a/modules/ssl/ssl_private.h
+++ b/modules/ssl/ssl_private.h
@@ -583,6 +583,32 @@
     SSL_SHUTDOWN_TYPE_ACCURATE
 } ssl_shutdown_type_e;
 
+/**
+ * Define the structure to hold clienthello variables
+ * (later exposed as environment vars)
+ */
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+typedef struct {
+    unsigned int version;
+    apr_size_t ciphers_len;
+    const unsigned char *ciphers_data;
+    apr_size_t compmethods_len;
+    const unsigned char *compmethods_data;
+    apr_size_t extids_len;
+    int *extids_data;
+    apr_size_t ecgroups_len;
+    const unsigned char *ecgroups_data;
+    apr_size_t ecformats_len;
+    const unsigned char *ecformats_data;
+    apr_size_t sigalgos_len;
+    const unsigned char *sigalgos_data;
+    apr_size_t alpn_len;
+    const unsigned char *alpn_data;
+    apr_size_t versions_len;
+    const unsigned char *versions_data;
+} modssl_clienthello_vars;
+#endif
+
 typedef struct {
     SSL *ssl;
     const char *client_dn;
@@ -613,6 +639,10 @@
     const char *cipher_suite; /* cipher suite used in last reneg */
     int service_unavailable;  /* thouugh we negotiate SSL, no requests will be served */
     int vhost_found;          /* whether we found vhost from SNI already */
+
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+    modssl_clienthello_vars *clienthello_vars;  /* info from clienthello callback */
+#endif
 } SSLConnRec;
 
 /* BIG FAT WARNING: SSLModConfigRec has unusual memory lifetime: it is
