Description: Adds fingerprinting variables
 <long description that can span multiple lines, optional>
Author: <name and email of author, optional>
Origin: <upstream|backport|vendor|other>, <URL, required except if Author is present>
Bug: <URL to the upstream bug report if any, implies patch has been forwarded, optional>
Bug-<Vendor>: <URL to the vendor bug report if any, optional>
Forwarded: <URL|no|not-needed, useless if you have a Bug field, optional>
Applied-Upstream: <version|URL|commit, identifies patches merged upstream, optional>
Reviewed-by: <name and email of a reviewer, optional>
Last-Update: 2024-09-03 <YYYY-MM-DD, last update of the meta-information, optional>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -1515,6 +1515,7 @@
     "SSL_SRP_USER",
     "SSL_SRP_USERINFO",
 #endif
+    "SSL_CLIENTHELLO_VERSION",
     NULL
 };
 
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -53,6 +53,7 @@
 static char *ssl_var_lookup_ssl_cipher(apr_pool_t *p, SSLConnRec *sslconn, char *var);
 static void  ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize);
 static char *ssl_var_lookup_ssl_version(apr_pool_t *p, char *var);
+static char *ssl_var_lookup_ssl_clienthello(apr_pool_t *p, SSL *ssl, char *var);
 static char *ssl_var_lookup_ssl_compress_meth(SSL *ssl);
 
 static SSLConnRec *ssl_get_effective_config(conn_rec *c)
@@ -387,6 +388,9 @@
     else if (ssl != NULL && strlen(var) >= 6 && strcEQn(var, "CIPHER", 6)) {
         result = ssl_var_lookup_ssl_cipher(p, sslconn, var+6);
     }
+    else if (ssl != NULL && strlen(var) >= 12 && strcEQn(var, "CLIENTHELLO_", 12)) {
+        result = ssl_var_lookup_ssl_clienthello(p, ssl, var+12);
+    }
     else if (ssl != NULL && strlen(var) > 18 && strcEQn(var, "CLIENT_CERT_CHAIN_", 18)) {
         sk = SSL_get_peer_cert_chain(ssl);
         result = ssl_var_lookup_ssl_cert_chain(p, sk, var+18);
@@ -867,6 +871,19 @@
     return result;
 }
 
+static char *ssl_var_lookup_ssl_clienthello(apr_pool_t *p, SSL *ssl, char *var)
+{
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+    if (ssl && strEQ(var, "VERSION")) {
+        return apr_itoa(p, SSL_client_version(ssl));
+    }
+#endif
+    return NULL;
+}
+
+
+
+
 static void ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize)
 {
     MODSSL_SSL_CIPHER_CONST SSL_CIPHER *cipher;
